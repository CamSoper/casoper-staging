### YamlMime:ManagedReference
items:
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  commentId: T:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  id: IReliableConcurrentQueue`1
  parent: Microsoft.ServiceFabric.Data.Collections.Preview
  children:
  - Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
  - Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  - Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  langs:
  - csharp
  - vb
  name: IReliableConcurrentQueue<T>
  nameWithType: IReliableConcurrentQueue<T>
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>
  type: Interface
  source:
    remote:
      path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
      branch: develop
      repo: https://msazure.visualstudio.com/DefaultCollection/One/_git/WindowsFabric
    id: IReliableConcurrentQueue
    path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
    startLine: 65
  assemblies:
  - Microsoft.ServiceFabric.Data.Interfaces
  namespace: Microsoft.ServiceFabric.Data.Collections.Preview
  summary: "\n<p>\nPreview feature. Not for production use. See the <a href=\"https://aka.ms/reliableconcurrentqueuepreview\">documentation</a> for details.\n</p>\n<p>\nRepresents a reliable collection of persisted, replicated values with best-effort first-in first-out ordering.\n</p>\n"
  remarks: "\n<p>\nIntended as an alternative to <xref href=\"Microsoft.ServiceFabric.Data.Collections.IReliableQueue%601\" data-throw-if-not-resolved=\"false\"></xref> for workloads where strict ordering is not required, as by relaxing\nthe ordering constraint, concurrency can be greatly improved.  <xref href=\"Microsoft.ServiceFabric.Data.Collections.IReliableQueue%601\" data-throw-if-not-resolved=\"false\"></xref> restricts concurrent consumers\nand producers to a maximum of one each, while <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601\" data-throw-if-not-resolved=\"false\"></xref> imposes no such restriction.\n</p>\n<p>\n<xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601\" data-throw-if-not-resolved=\"false\"></xref> does not offer the same transaction isolation semantics as the other reliable data structures.  See the \nindividual operations and properties (<xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction%2c%600%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.Count\" data-throw-if-not-resolved=\"false\"></xref>) for details on what isolation, \nif any, they provide.\n</p>\n<p>\nIt is expected that values will be relatively short-lived in the queue; in other words, that the egress (<xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref>) rate is \nequal to or greater than the ingress (<xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction%2c%600%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref>) rate.  Violating this expectation \nmay worsen system performance.  A planned queue capacity constraint which will throttle incoming Enqueues once the capacity is reached\nwill help in maintaining this property.\nproperty.\n</p>\n<p>\nAs the ordering of elements is not strictly guaranteed, assumptions about the ordering of any two values in the queue MUST NOT\nbe made.  The best-effort first-in first-out ordering is provided for fairness; the time that an value spends in the queue should\nbe related to the failure rate (failures may alter the queue's ordering) and the dequeue rate, but not the enqueue rate.\n</p>\n<p>\n<xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601\" data-throw-if-not-resolved=\"false\"></xref> does not offer a Peek operation, however by combining <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"Microsoft.ServiceFabric.Data.ITransaction.Abort\" data-throw-if-not-resolved=\"false\"></xref>\nthe same semantic can be achieved.  See <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> for additional details and an example.\n</p>\n<p>\nValues stored in this queue MUST NOT be mutated outside the context of an operation on the queue. It is\nhighly recommended to make <em>T</em> immutable in order to avoid accidental data corruption.\n</p>\n<p>\nTransaction is the unit of concurrency: Users can have multiple transactions in-flight at any given point of time but for a given transaction each API must be called one at a time.\nSo all Reliable Collection APIs that take in a transaction and return a Task, must be awaited one at a time.\n<xref href=\"Microsoft.ServiceFabric.Data.ITransaction\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n"
  example: []
  syntax:
    content: 'public interface IReliableConcurrentQueue<T> : IReliableState'
    content.vb: >-
      Public Interface IReliableConcurrentQueue(Of T)
          Inherits IReliableState
    typeParameters:
    - id: T
      description: "\nThe type of the values contained in the reliable queue slim.\n"
  inheritedMembers:
  - Microsoft.ServiceFabric.Data.IReliableState.Name
  extensionMethods:
  - Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1
  nameWithType.vb: IReliableConcurrentQueue(Of T)
  modifiers.csharp:
  - public
  - interface
  modifiers.vb:
  - Public
  - Interface
  fullName.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T)
  name.vb: IReliableConcurrentQueue(Of T)
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  commentId: M:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  id: EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  parent: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  langs:
  - csharp
  - vb
  name: EnqueueAsync(ITransaction, T, CancellationToken, Nullable<TimeSpan>)
  nameWithType: IReliableConcurrentQueue<T>.EnqueueAsync(ITransaction, T, CancellationToken, Nullable<TimeSpan>)
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction, T, System.Threading.CancellationToken, System.Nullable<System.TimeSpan>)
  type: Method
  source:
    remote:
      path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
      branch: develop
      repo: https://msazure.visualstudio.com/DefaultCollection/One/_git/WindowsFabric
    id: EnqueueAsync
    path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
    startLine: 156
  assemblies:
  - Microsoft.ServiceFabric.Data.Interfaces
  namespace: Microsoft.ServiceFabric.Data.Collections.Preview
  summary: "\n<p>\nPreview feature. Not for production use. See the <a href=\"https://aka.ms/reliableconcurrentqueuepreview\">documentation</a> for details.\n</p>\n<p>\nStage the enqueue of a value into the queue.\n</p>\n"
  remarks: "\nA <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> operation cannot return any value for which its <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction%2c%600%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> has not yet been committed.\nThis includes the transaction in which the value was enqueued; as a consequence, <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601\" data-throw-if-not-resolved=\"false\"></xref> does not support Read-Your-Writes.\n"
  example:
  - "\nThis example shows how to use <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction%2c%600%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> to enqueue a value with retry.\n<pre><code>protected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    var concurrentQueue = await this.StateManager.GetOrAddAsync&lt;IReliableConcurrentQueue&lt;long&gt;&gt;(new Uri(\"fabric:/concurrentQueue\"));\n\n    while (true)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n\n        try\n        {\n            using (var tx = this.StateManager.CreateTransaction())\n            {\n                await concurrentQueue.EnqueueAsync(tx, 12L, cancellationToken);\n                await tx.CommitAsync();\n\n                return;\n            }\n        }\n        catch (FabricNotPrimaryException e)\n        {\n            // Gracefully exit RunAsync as the new primary should have RunAsync invoked on it and continue work.\n            // If instead enqueue was being executed as part of a client request, the client would be signaled to re-resolve.\n            Console.WriteLine(\"Replica is not primary, exiting RunAsync: \" + e);\n            return;\n        }\n        catch (FabricNotReadableException e)\n        {\n            // Retry until the queue is readable or a different exception is thrown.\n            Console.WriteLine(\"Queue is not readable, retrying the transaction: \" + e);\n        }\n        catch (FabricObjectClosedException e)\n        {\n            // Gracefully exit RunAsync as this is happening due to replica close.\n            // If instead enqueue was being executed as part of a client request, the client would be signaled to re-resolve.\n            Console.WriteLine(\"Replica is closing, exiting RunAsync: \" + e);\n            return;\n        }\n        catch (TimeoutException e)\n        {\n            Console.WriteLine(\"Encountered TimeoutException during EnqueueAsync, retrying the transaction: \" + e);\n        }\n\n        // Delay and retry.\n        await Task.Delay(TimeSpan.FromMilliseconds(100), cancellationToken);\n    }\n}</code></pre>\n"
  syntax:
    content: Task EnqueueAsync(ITransaction tx, T value, CancellationToken cancellationToken = null, TimeSpan? timeout = null)
    content.vb: Function EnqueueAsync(tx As ITransaction, value As T, cancellationToken As CancellationToken = Nothing, timeout As TimeSpan? = Nothing) As Task
    parameters:
    - id: tx
      type: Microsoft.ServiceFabric.Data.ITransaction
      description: Transaction to associate this operation with.
    - id: value
      type: '{T}'
      description: The value to add to the end of the queue. The value can be null for reference types.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The token to monitor for cancellation requests. The default is <xref href="System.Threading.CancellationToken.None" data-throw-if-not-resolved="false"></xref>.
    - id: timeout
      type: System.Nullable{System.TimeSpan}
      description: The amount of time to wait for the operation to complete before throwing a TimeoutException. The default is null.  If null is passed, a default timeout will be used.
    return:
      type: System.Threading.Tasks.Task
      description: Task that represents the asynchronous enqueue operation.
  overload: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync*
  exceptions:
  - type: System.Fabric.FabricNotPrimaryException
    commentId: T:System.Fabric.FabricNotPrimaryException
    description: The replica is no longer in <cref name="ReplicaRole.Primary"></cref>.
  - type: System.Fabric.FabricNotReadableException
    commentId: T:System.Fabric.FabricNotReadableException
    description: The replica is currently not readable.
  - type: System.Fabric.FabricObjectClosedException
    commentId: T:System.Fabric.FabricObjectClosedException
    description: The <xref href="Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601" data-throw-if-not-resolved="false"></xref> was closed by the runtime.
  - type: System.TimeoutException
    commentId: T:System.TimeoutException
    description: "\nThe operation was unable to be completed within the given timeout.  The transaction should be aborted and\na new transaction should be created to retry.\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <em>tx</em> is null.
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: The operation was canceled via <em>cancellationToken</em>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\nThrown when a method call is invalid for the object's current state.\nExample, transaction used is already terminated: committed or aborted.\n"
  nameWithType.vb: IReliableConcurrentQueue(Of T).EnqueueAsync(ITransaction, T, CancellationToken, Nullable(Of TimeSpan))
  fullName.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction, T, System.Threading.CancellationToken, System.Nullable(Of System.TimeSpan))
  name.vb: EnqueueAsync(ITransaction, T, CancellationToken, Nullable(Of TimeSpan))
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  commentId: M:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  id: DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  parent: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  langs:
  - csharp
  - vb
  name: DequeueAsync(ITransaction, CancellationToken, Nullable<TimeSpan>)
  nameWithType: IReliableConcurrentQueue<T>.DequeueAsync(ITransaction, CancellationToken, Nullable<TimeSpan>)
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction, System.Threading.CancellationToken, System.Nullable<System.TimeSpan>)
  type: Method
  source:
    remote:
      path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
      branch: develop
      repo: https://msazure.visualstudio.com/DefaultCollection/One/_git/WindowsFabric
    id: DequeueAsync
    path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
    startLine: 258
  assemblies:
  - Microsoft.ServiceFabric.Data.Interfaces
  namespace: Microsoft.ServiceFabric.Data.Collections.Preview
  summary: "\n<p>\nPreview feature. Not for production use. See the <a href=\"https://aka.ms/reliableconcurrentqueuepreview\">documentation</a> for details.\n</p>\n<p>\nTentatively dequeue a value from the queue.\n</p>\n"
  remarks: "\n<p>\nWhile <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> can only return values for which the corresponding <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction%2c%600%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> was committed, Dequeue operations are not isolated\nfrom one another.  Once a transaction has dequeued a value, other transactions cannot dequeue it, but are not blocked from dequeuing other values.\n</p>\n<p>\nWhen a transaction or transactions including one or more <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> operations aborts, the dequeued values will be added back at\nthe head of the queue in an arbitrary order.  This will ensure that these values will be dequeued again soon, improving the fairness of the\ndata structure, but without enforcing strict ordering (which would require reducing the allowed concurrency, as in <xref href=\"Microsoft.ServiceFabric.Data.Collections.IReliableQueue%601\" data-throw-if-not-resolved=\"false\"></xref>).\n</p>\n"
  example:
  - "\nThis example shows how to dequeue and log infinitely with retry, until the cancellation token is canceled.  \n<pre><code>protected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    var concurrentQueue = await this.StateManager.GetOrAddAsync&lt;IReliableConcurrentQueue&lt;long&gt;&gt;(new Uri(\"fabric:/concurrentQueue\"));\n\n    // Assumption: values are being enqueued by another source (e.g. the communication listener).\n    while (true)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n\n        try\n        {\n            using (var tx = this.StateManager.CreateTransaction())\n            {\n                var dequeueOutput = await concurrentQueue.DequeueAsync(tx, cancellationToken);\n                await tx.CommitAsync();\n                Console.WriteLine(\"Dequeue #\" + dequeueOutput);\n            }\n        }\n        catch (FabricNotPrimaryException e)\n        {\n            // Gracefully exit RunAsync as the new primary should have RunAsync invoked on it and continue work.\n            // If instead dequeue was being executed as part of a client request, the client would be signaled to re-resolve.\n            Console.WriteLine(\"Replica is not primary, exiting RunAsync: \" + e);\n            return;\n        }\n        catch (FabricNotReadableException e)\n        {\n            // Retry until the queue is readable or a different exception is thrown.\n            Console.WriteLine(\"Queue is not readable, retrying the transaction: \" + e);\n        }\n        catch (FabricObjectClosedException e)\n        {\n            // Gracefully exit RunAsync as this is happening due to replica close.\n            // If instead dequeue was being executed as part of a client request, the client would be signaled to re-resolve.\n            Console.WriteLine(\"Replica is closing, exiting RunAsync: \" + e);\n            return;\n        }\n        catch (QueueEmptyException e)\n        {\n            Console.WriteLine(\"Queue was empty for DequeueAsync, retrying the transaction: \" + e);\n        }\n        catch (TimeoutException e)\n        {\n            Console.WriteLine(\"Encountered TimeoutException during DequeueAsync, retrying the transaction: \" + e);\n        }\n\n        // Delay and retry.\n        await Task.Delay(TimeSpan.FromMilliseconds(100), cancellationToken);\n    }\n}</code></pre>\n"
  syntax:
    content: Task<T> DequeueAsync(ITransaction tx, CancellationToken cancellationToken = null, TimeSpan? timeout = null)
    content.vb: Function DequeueAsync(tx As ITransaction, cancellationToken As CancellationToken = Nothing, timeout As TimeSpan? = Nothing) As Task(Of T)
    parameters:
    - id: tx
      type: Microsoft.ServiceFabric.Data.ITransaction
      description: Transaction to associate this operation with.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The token to monitor for cancellation requests. The default is <xref href="System.Threading.CancellationToken.None" data-throw-if-not-resolved="false"></xref>.
    - id: timeout
      type: System.Nullable{System.TimeSpan}
      description: The amount of time to wait for the operation to complete before throwing a TimeoutException. The default is null.  If null is passed, a default timeout will be used.
    return:
      type: System.Threading.Tasks.Task{{T}}
      description: A task that represents the asynchronous dequeue operation.  The task result is the value dequeued.
  overload: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync*
  exceptions:
  - type: System.Fabric.FabricNotPrimaryException
    commentId: T:System.Fabric.FabricNotPrimaryException
    description: The replica is no longer in <cref name="ReplicaRole.Primary"></cref>.
  - type: System.Fabric.FabricNotReadableException
    commentId: T:System.Fabric.FabricNotReadableException
    description: The replica is currently not readable.
  - type: System.Fabric.FabricObjectClosedException
    commentId: T:System.Fabric.FabricObjectClosedException
    description: The <xref href="Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601" data-throw-if-not-resolved="false"></xref> was closed by the runtime.
  - type: Microsoft.ServiceFabric.Data.Collections.Preview.QueueEmptyException
    commentId: T:Microsoft.ServiceFabric.Data.Collections.Preview.QueueEmptyException
    description: "\nThe queue is currently empty.  Retriable; when encountering this exception, the caller should wait some time for additional enqueue operations\nbefore issuing another dequeue."
  - type: System.TimeoutException
    commentId: T:System.TimeoutException
    description: "\nThe operation was unable to be completed within the given timeout.  The transaction should be aborted and\na new transaction should be created to retry.\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <em>tx</em> is null.
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: The operation was canceled via <em>cancellationToken</em>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\nThrown when a method call is invalid for the object's current state.\nExample, transaction used is already terminated: committed or aborted.\n"
  nameWithType.vb: IReliableConcurrentQueue(Of T).DequeueAsync(ITransaction, CancellationToken, Nullable(Of TimeSpan))
  fullName.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction, System.Threading.CancellationToken, System.Nullable(Of System.TimeSpan))
  name.vb: DequeueAsync(ITransaction, CancellationToken, Nullable(Of TimeSpan))
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
  commentId: P:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
  id: Count
  parent: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  langs:
  - csharp
  - vb
  name: Count
  nameWithType: IReliableConcurrentQueue<T>.Count
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.Count
  type: Property
  source:
    remote:
      path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
      branch: develop
      repo: https://msazure.visualstudio.com/DefaultCollection/One/_git/WindowsFabric
    id: Count
    path: src/prod/src/managed/Microsoft.ServiceFabric.Data.Interfaces/Collections/Preview/IReliableConcurrentQueue.cs
    startLine: 323
  assemblies:
  - Microsoft.ServiceFabric.Data.Interfaces
  namespace: Microsoft.ServiceFabric.Data.Collections.Preview
  summary: "\n<p>\nPreview feature. Not for production use. See the <a href=\"https://aka.ms/reliableconcurrentqueuepreview\">documentation</a> for details.\n</p>\n<p>\nGets the number of values in the <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
  remarks: "\n<p>\nThis count represents the number of values currently visible to <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref>.  Uncommitted Enqueues will not\nincrease the count, however uncommitted Dequeues will decrease the count.\n</p>\n<p>\nNote that this API does not take a transaction parameter.  Since the effects of <xref href=\"Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction%2cSystem.Threading.CancellationToken%2cSystem.Nullable%7bSystem.TimeSpan%7d)\" data-throw-if-not-resolved=\"false\"></xref> are not isolated\nfrom other transactions, the count also cannot be isolated from other transactions.  \n</p>\n"
  example:
  - "\nThis example shows how to monitor the queue's count infinitely, until the cancellation token is canceled.\n<pre><code>protected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    var concurrentQueue = await this.StateManager.GetOrAddAsync&lt;IReliableConcurrentQueue&lt;long&gt;&gt;(new Uri(\"fabric:/concurrentQueue\"));\n\n    // Assumption: values are being enqueued/dequeued in another place (e.g. the communication listener).\n    var observer = Task.Run(\n        async () =&gt;\n            {\n                while (true)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    try\n                    {\n                        Console.WriteLine(\"Count: \" + concurrentQueue.Count);\n                    }\n                    catch (FabricNotReadableException e)\n                    {\n                        // Retry until the queue is readable or a different exception is thrown.\n                        Console.WriteLine(\"Queue is not readable, retrying the observation: \" + e);\n                    }\n                    catch (FabricObjectClosedException e)\n                    {\n                        // Gracefully exit as this is happening due to replica close.\n                        Console.WriteLine(\"Replica is closing, stopping observer: \" + e);\n                        return;\n                    }\n\n                    await Task.Delay(TimeSpan.FromMilliseconds(100), cancellationToken);\n                }\n            },\n        cancellationToken);\n}</code></pre>\n"
  syntax:
    content: long Count { get; }
    content.vb: ReadOnly Property Count As Long
    parameters: []
    return:
      type: System.Int64
      description: The number of values in  the <xref href="Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601" data-throw-if-not-resolved="false"></xref>.
  overload: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count*
  exceptions:
  - type: System.Fabric.FabricNotReadableException
    commentId: T:System.Fabric.FabricNotReadableException
    description: The replica is currently not readable.
  - type: System.Fabric.FabricObjectClosedException
    commentId: T:System.Fabric.FabricObjectClosedException
    description: The <xref href="Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue%601" data-throw-if-not-resolved="false"></xref> was closed by the runtime.
  nameWithType.vb: IReliableConcurrentQueue(Of T).Count
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  fullName.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).Count
references:
- uid: Microsoft.ServiceFabric.Data.Collections.IReliableQueue`1
  commentId: T:Microsoft.ServiceFabric.Data.Collections.IReliableQueue`1
  isExternal: false
  name: IReliableQueue<T>
  nameWithType: IReliableQueue<T>
  fullName: Microsoft.ServiceFabric.Data.Collections.IReliableQueue<T>
  nameWithType.vb: IReliableQueue(Of T)
  fullname.vb: Microsoft.ServiceFabric.Data.Collections.IReliableQueue(Of T)
  name.vb: IReliableQueue(Of T)
  spec.csharp:
  - uid: Microsoft.ServiceFabric.Data.Collections.IReliableQueue`1
    name: IReliableQueue
    nameWithType: IReliableQueue
    fullName: Microsoft.ServiceFabric.Data.Collections.IReliableQueue
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Microsoft.ServiceFabric.Data.Collections.IReliableQueue`1
    name: IReliableQueue
    nameWithType: IReliableQueue
    fullName: Microsoft.ServiceFabric.Data.Collections.IReliableQueue
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  commentId: T:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
  isExternal: false
  name: IReliableConcurrentQueue<T>
  nameWithType: IReliableConcurrentQueue<T>
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>
  nameWithType.vb: IReliableConcurrentQueue(Of T)
  fullname.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T)
  name.vb: IReliableConcurrentQueue(Of T)
  spec.csharp:
  - uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
    name: IReliableConcurrentQueue
    nameWithType: IReliableConcurrentQueue
    fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1
    name: IReliableConcurrentQueue
    nameWithType: IReliableConcurrentQueue
    fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  commentId: M:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync(Microsoft.ServiceFabric.Data.ITransaction,`0,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
  commentId: M:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync(Microsoft.ServiceFabric.Data.ITransaction,System.Threading.CancellationToken,System.Nullable{System.TimeSpan})
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
  commentId: P:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
- uid: Microsoft.ServiceFabric.Data.ITransaction.Abort
  commentId: M:Microsoft.ServiceFabric.Data.ITransaction.Abort
  parent: Microsoft.ServiceFabric.Data.ITransaction
  isExternal: false
  name: Abort()
  nameWithType: ITransaction.Abort()
  fullName: Microsoft.ServiceFabric.Data.ITransaction.Abort()
  spec.csharp:
  - uid: Microsoft.ServiceFabric.Data.ITransaction.Abort
    name: Abort
    nameWithType: ITransaction.Abort
    fullName: Microsoft.ServiceFabric.Data.ITransaction.Abort
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: Microsoft.ServiceFabric.Data.ITransaction.Abort
    name: Abort
    nameWithType: ITransaction.Abort
    fullName: Microsoft.ServiceFabric.Data.ITransaction.Abort
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: Microsoft.ServiceFabric.Data.ITransaction
  commentId: T:Microsoft.ServiceFabric.Data.ITransaction
  parent: Microsoft.ServiceFabric.Data
  isExternal: false
  name: ITransaction
  nameWithType: ITransaction
  fullName: Microsoft.ServiceFabric.Data.ITransaction
- uid: Microsoft.ServiceFabric.Data.Collections.Preview
  commentId: N:Microsoft.ServiceFabric.Data.Collections.Preview
  isExternal: false
  name: Microsoft.ServiceFabric.Data.Collections.Preview
  nameWithType: Microsoft.ServiceFabric.Data.Collections.Preview
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview
- uid: Microsoft.ServiceFabric.Data.IReliableState.Name
  commentId: P:Microsoft.ServiceFabric.Data.IReliableState.Name
  parent: Microsoft.ServiceFabric.Data.IReliableState
  isExternal: false
  name: Name
  nameWithType: IReliableState.Name
  fullName: Microsoft.ServiceFabric.Data.IReliableState.Name
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1
  commentId: M:System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
  parent: System.Fabric.Messaging.Stream.ByteArraySerializer
  definition: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
  name: Serialize<IReliableConcurrentQueue<T>>()
  nameWithType: ByteArraySerializer.Serialize<IReliableConcurrentQueue<T>>()
  fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize<Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>>()
  nameWithType.vb: ByteArraySerializer.Serialize(Of IReliableConcurrentQueue(Of T))()
  fullname.vb: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize(Of Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T))()
  name.vb: Serialize(Of IReliableConcurrentQueue(Of T))()
  spec.csharp:
  - uid: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1
    name: Serialize<IReliableConcurrentQueue<T>>
    nameWithType: ByteArraySerializer.Serialize<IReliableConcurrentQueue<T>>
    fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize<Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>>
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1
    name: Serialize(Of IReliableConcurrentQueue(Of T))
    nameWithType: ByteArraySerializer.Serialize(Of IReliableConcurrentQueue(Of T))
    fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize(Of Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T))
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: Microsoft.ServiceFabric.Data
  commentId: N:Microsoft.ServiceFabric.Data
  isExternal: false
  name: Microsoft.ServiceFabric.Data
  nameWithType: Microsoft.ServiceFabric.Data
  fullName: Microsoft.ServiceFabric.Data
- uid: Microsoft.ServiceFabric.Data.IReliableState
  commentId: T:Microsoft.ServiceFabric.Data.IReliableState
  parent: Microsoft.ServiceFabric.Data
  isExternal: false
  name: IReliableState
  nameWithType: IReliableState
  fullName: Microsoft.ServiceFabric.Data.IReliableState
- uid: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
  commentId: M:System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
  isExternal: false
  name: Serialize<T>(T)
  nameWithType: ByteArraySerializer.Serialize<T>(T)
  fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize<T>(T)
  nameWithType.vb: ByteArraySerializer.Serialize(Of T)(T)
  fullname.vb: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize(Of T)(T)
  name.vb: Serialize(Of T)(T)
  spec.csharp:
  - uid: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
    name: Serialize<T>
    nameWithType: ByteArraySerializer.Serialize<T>
    fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize<T>
  - name: (
    nameWithType: (
    fullName: (
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize``1(``0)
    name: Serialize(Of T)
    nameWithType: ByteArraySerializer.Serialize(Of T)
    fullName: System.Fabric.Messaging.Stream.ByteArraySerializer.Serialize(Of T)
  - name: (
    nameWithType: (
    fullName: (
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Fabric.Messaging.Stream.ByteArraySerializer
  commentId: T:System.Fabric.Messaging.Stream.ByteArraySerializer
  parent: System.Fabric.Messaging.Stream
  isExternal: false
  name: ByteArraySerializer
  nameWithType: ByteArraySerializer
  fullName: System.Fabric.Messaging.Stream.ByteArraySerializer
- uid: System.Fabric.Messaging.Stream
  commentId: N:System.Fabric.Messaging.Stream
  isExternal: false
  name: System.Fabric.Messaging.Stream
  nameWithType: System.Fabric.Messaging.Stream
  fullName: System.Fabric.Messaging.Stream
- uid: System.Threading.CancellationToken.None
  commentId: P:System.Threading.CancellationToken.None
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync*
  commentId: Overload:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.EnqueueAsync
  isExternal: false
  name: EnqueueAsync
  nameWithType: IReliableConcurrentQueue<T>.EnqueueAsync
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.EnqueueAsync
  nameWithType.vb: IReliableConcurrentQueue(Of T).EnqueueAsync
  fullname.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).EnqueueAsync
- uid: System.Fabric.FabricNotPrimaryException
  commentId: T:System.Fabric.FabricNotPrimaryException
  isExternal: false
  name: FabricNotPrimaryException
  nameWithType: FabricNotPrimaryException
  fullName: System.Fabric.FabricNotPrimaryException
- uid: System.Fabric.FabricNotReadableException
  commentId: T:System.Fabric.FabricNotReadableException
  isExternal: false
  name: FabricNotReadableException
  nameWithType: FabricNotReadableException
  fullName: System.Fabric.FabricNotReadableException
- uid: System.Fabric.FabricObjectClosedException
  commentId: T:System.Fabric.FabricObjectClosedException
  isExternal: false
  name: FabricObjectClosedException
  nameWithType: FabricObjectClosedException
  fullName: System.Fabric.FabricObjectClosedException
- uid: System.TimeoutException
  commentId: T:System.TimeoutException
- uid: System.ArgumentNullException
  commentId: T:System.ArgumentNullException
- uid: System.OperationCanceledException
  commentId: T:System.OperationCanceledException
- uid: System.InvalidOperationException
  commentId: T:System.InvalidOperationException
  parent: System
  isExternal: true
  name: InvalidOperationException
  nameWithType: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: '{T}'
  commentId: '!:T'
  definition: T
  name: T
  nameWithType: T
  fullName: T
- uid: System.Threading.CancellationToken
  commentId: T:System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Nullable{System.TimeSpan}
  commentId: T:System.Nullable{System.TimeSpan}
  parent: System
  definition: System.Nullable`1
  name: Nullable<TimeSpan>
  nameWithType: Nullable<TimeSpan>
  fullName: System.Nullable<System.TimeSpan>
  nameWithType.vb: Nullable(Of TimeSpan)
  fullname.vb: System.Nullable(Of System.TimeSpan)
  name.vb: Nullable(Of TimeSpan)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.TimeSpan
    name: TimeSpan
    nameWithType: TimeSpan
    fullName: System.TimeSpan
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.TimeSpan
    name: TimeSpan
    nameWithType: TimeSpan
    fullName: System.TimeSpan
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.Task
  commentId: T:System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System
  commentId: N:System
  isExternal: false
  name: System
  nameWithType: System
  fullName: System
- uid: T
  isExternal: false
  name: T
  nameWithType: T
  fullName: T
- uid: System.Threading
  commentId: N:System.Threading
  isExternal: false
  name: System.Threading
  nameWithType: System.Threading
  fullName: System.Threading
- uid: System.Nullable`1
  commentId: T:System.Nullable`1
  isExternal: true
  name: Nullable<T>
  nameWithType: Nullable<T>
  fullName: System.Nullable<T>
  nameWithType.vb: Nullable(Of T)
  fullname.vb: System.Nullable(Of T)
  name.vb: Nullable(Of T)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks
  commentId: N:System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  nameWithType: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync*
  commentId: Overload:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.DequeueAsync
  isExternal: false
  name: DequeueAsync
  nameWithType: IReliableConcurrentQueue<T>.DequeueAsync
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.DequeueAsync
  nameWithType.vb: IReliableConcurrentQueue(Of T).DequeueAsync
  fullname.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).DequeueAsync
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.QueueEmptyException
  commentId: T:Microsoft.ServiceFabric.Data.Collections.Preview.QueueEmptyException
  isExternal: false
  name: QueueEmptyException
  nameWithType: QueueEmptyException
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.QueueEmptyException
- uid: System.Threading.Tasks.Task{{T}}
  commentId: T:System.Threading.Tasks.Task{``0}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<T>
  nameWithType: Task<T>
  fullName: System.Threading.Tasks.Task<T>
  nameWithType.vb: Task(Of T)
  fullname.vb: System.Threading.Tasks.Task(Of T)
  name.vb: Task(Of T)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  commentId: T:System.Threading.Tasks.Task`1
  isExternal: true
  name: Task<TResult>
  nameWithType: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  nameWithType.vb: Task(Of TResult)
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count*
  commentId: Overload:Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue`1.Count
  isExternal: false
  name: Count
  nameWithType: IReliableConcurrentQueue<T>.Count
  fullName: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue<T>.Count
  nameWithType.vb: IReliableConcurrentQueue(Of T).Count
  fullname.vb: Microsoft.ServiceFabric.Data.Collections.Preview.IReliableConcurrentQueue(Of T).Count
- uid: System.Int64
  commentId: T:System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
